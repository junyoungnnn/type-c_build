export class Motion {
    constructor(props) {
        this._playCount = 0;
        this.state = {};
        this.duration = 1000;
        this.progress = 0;
        this.startTime = 0;
        this.currentFrame = 0;
        this.easing = (x) => x;
        this.then = (state) => { };
        this.chainAfter = () => { };
        this._reset = () => () => { };
        this._stopped = true;
        this._paused = false;
        this.reverse = false;
        this.loop = LoopType.NONE;
        this.id = ++Motion.NEXT_ID;
        if (props.easing != undefined)
            this.easing = props.easing;
        if (props.duration != undefined)
            this.duration = props.duration;
        if (props.reverse != undefined)
            this.reverse = props.reverse;
        if (props.loop != undefined)
            this.loop = props.loop;
        if (props.then != undefined)
            this.then = props.then;
        if (props.state != undefined)
            this.state = props.state;
        if (props.reset != undefined)
            this._reset = props.reset;
        this.animation = props.animation;
    }
    get playCount() {
        return this._playCount;
    }
    get stopped() {
        return this._stopped;
    }
    get isPaused() {
        return this._paused;
    }
    static preform(p) {
        let x = new Motion(p);
        x.play();
        return x;
    }
    play() {
        this._paused = false;
        this._stopped = false;
        for (let i of Engine.activeInstances)
            if (i.id == this.id)
                return;
        Engine.activeInstances.push(this);
        if (!Engine.frameID)
            Engine.run();
    }
    tick(time) {
        this.currentFrame = time;
        if (!this.startTime)
            this.startTime = time;
        if (time - this.startTime + this.progress >= this.duration) {
            this.animation(this.reverse ? 0 : 1, this.state);
            this._playCount++;
            this.then(this.state);
            if (this.loop != LoopType.NONE) {
                this.startTime = 0;
                this.progress = 0;
                if (this.loop == LoopType.ALTERNATE)
                    this.reverse = !this.reverse;
            }
            else {
                this.stop();
                this.chainAfter();
            }
        }
        else {
            let percentage = (time - this.startTime + this.progress) / this.duration;
            let mappedX = this.easing(percentage);
            this.animation(this.reverse ? 1 - mappedX : mappedX, this.state);
        }
    }
    pause() {
        if (!this._stopped) {
            this.progress += this.currentFrame - this.startTime;
            this.startTime = 0;
            this._paused = true;
        }
    }
    stop() {
        this._stopped = true;
        this._paused = false;
        this.startTime = 0;
        this.progress = 0;
    }
    rewind() {
        if (!this._stopped) {
            this.reverse = !this.reverse;
            this.progress = this.duration - (this.currentFrame - this.startTime);
            this.startTime = 0;
        }
    }
    reset() {
        this.stop();
        this.animation(0, this.state);
        this._reset();
    }
    setChain(func) {
        this.chainAfter = func;
    }
}
Motion.NEXT_ID = 0;
class Engine {
    static run() {
        if (Engine.activeInstances.length)
            Engine.frameID = requestAnimationFrame(Engine.tick);
        else {
            cancelAnimationFrame(Engine.frameID);
            Engine.frameID = null;
        }
    }
    static tick(time) {
        for (let i = Engine.activeInstances.length - 1; i >= 0; i--) {
            let instance = Engine.activeInstances[i];
            if (instance.stopped || instance.isPaused)
                Engine.activeInstances.splice(i, 1);
            else
                instance.tick(time);
        }
        Engine.run();
    }
}
Engine.frameID = null;
Engine.activeInstances = [];
export class MotionChain {
    constructor(instances) {
        this.animationInstances = [];
        this.runningInstances = [];
        this.runningIndex = 0;
        for (let instance of instances) {
            this.animationInstances.push(new Motion(instance));
        }
    }
    play(reverse = false) {
        this.runningInstances = this.animationInstances.slice();
        if (reverse)
            this.runningInstances.reverse();
        for (let i of this.runningInstances)
            i.reverse = reverse;
        this.run();
    }
    togglePause() {
        if (this.runningInstances.length > 0) {
            if (this.runningInstances[this.runningIndex].isPaused)
                this.runningInstances[this.runningIndex].play();
            else
                this.runningInstances[this.runningIndex].pause();
        }
    }
    run() {
        for (let i = 0; i < this.runningInstances.length; i++) {
            if (i < this.runningInstances.length - 1)
                this.runningInstances[i].setChain(() => {
                    this.runningInstances[i + 1].play();
                    this.runningIndex++;
                });
            else
                this.runningInstances[i].setChain(() => {
                    this.runningInstances = [];
                    this.runningIndex = 0;
                });
        }
        this.runningInstances[0].play();
    }
}
var LoopType;
(function (LoopType) {
    LoopType[LoopType["NONE"] = 0] = "NONE";
    LoopType[LoopType["LOOP"] = 1] = "LOOP";
    LoopType[LoopType["ALTERNATE"] = 2] = "ALTERNATE";
})(LoopType || (LoopType = {}));
//# sourceMappingURL=motion.js.map